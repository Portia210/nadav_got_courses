1) מה זה מערכת הפעלה
מחשב מורכב מהרבה רכיבי חומרה, יש רכיבי אינפוט, אאוטפוט או שניהם ביחד
מערכת ההפעלה היא המתווך בינינו לבין המחשב
בשפות נמוכות באמת לפעמים צריך לדבר עם הרכיבים של המחשב באופן ישיר 

2) מושגים במערכות הפעלה
ram = random access memeory, נקרא זיכרון נדיף, כי הוא עובד רק כאשר זורם אליו חשמל, כשמנתנק החשמל נמחק כל הזיכרון
כדי לשמור את המידע בצורה קשיחה שלא מתנדפת יש 2 רכיבים, דיסק קשיח או זיכרון נייד HDD SSD
rom = read only memory, only output (not relevant)

יש כמה שכבות : קוד, מערכת הפעלה, דריברים, רכיבים (הדריברים הם הרכיבים המקשרים בין המערכת הפעלה לרכיבים, שכבת הדריברים נקראת שכבת אבסטרקציה 
OS = Operating system


3) תפקידי מערכת ההפעלה
ניהול RAM (לכתוב למחוק לערוך להקצות)
ניהול קבצים  (לכתוב למחוק לגשת לערוך מבנה הקבצים נתיבים)
לגשת לרכיבים הקיפיים (פריפריאלים) 
ניהול תהליכים (פרוססים) , כאשר הקוד רק הוא הופך בתהליך, המערכת מקצה זיכרון ומעבד לפרוססים מריצה ומכבה אותם, 
ניהול אבטחה, מי יכול לגשת למה
בגדול הרעיון שלה היא לנהל את המשאבים בצורה היעילה ביותר

4) תהליכים
כשהרצנו את הקוד :
1. בא מתרגם ומתרגם את הקוד לשפת מחשב (כל קובץ EXE למשל הוא שפת מחשב), התהליך שלעבור משפת מחשב לשפת אדם היא כמעט בלתי אפשרית
תהליך ההמרה הזה לשפת מחשב, נקרא קימפול, exe or dmg הם executable (ברי ביצוע) למחשב
ברגע שאני מריץ קובץ exe מערכת ההפעלה צריכה להקצות לנו כתובת לטובת הקוד, גם זמן מעבד
* בניגוד למה שאנו חושבים, מעבד יכול לעשות בכל זמן רק דבר אחד 
מרגע שהתחלנו את התהליך הקובץ מפסיק להיות קובץ ומתחיל להיות תהליך
 מערכת ההפעלה מזהה כל פרוסס לפי ID (PID) 
 בדרך כלל תוכנות שקשורות למערכת ההפעלה היא תשתמש בPID נמוכים ותוכנות רגילות יהיו עם PID גבוהים (כנל לגבי כתובות)
 KERNEL > גרעין, הוא הגרעין של מערכת ההפעלה והוא מקצה משאבים לתהליכים
 
 
5) מצבים אפשריים לתהליך
1. חדש : הקובץ נטען לזיכרון (משם הוא מורץ, לא מהקובץ)
2. מוכן: הקובץ מוכן לזמן מעבד וממתין שהמעבד יהיה פנוי
3. רץ: המעבד מריץ אותו
4. מחכה: התהליך מחכה לאינפוט או אאוטפוט
5. הסתיים

6) מבנה הפרוסס
הרעיון של מעבר בין מצבים שדיברנו בשיעור הקודם נקרא: 
מכונת מצבים - state machine
דמינו רשימה של הרבה פרוססים, ולכל פרוסס של את הפרטים שלו עם כל הנתונים
בואו נדבר על הנתונים של כל פרוסס PCB process control block
1. state (מוכן/רץ וכו')
2. pid תעודת הזהות של הפרוסס
3. program counter, הוא סופר למעבד באיזה שורה הקוד נמצא (אם הקוד הופרע, הוא זוכר עבור המעבר איפה הוא עצר) 
4. registers/אוגר, אם צריך להשתמש בתכונות מסויימות של המחשב שם זה מוגדר
5. גבולות זיכרון, מאגר כתובות שהתהליך יכול להשתמש בהן
6. רשימת קבצים פתוחים ע"י הפרוסס, חשוב לזכור כמו שדיברנו, כי כל עוד הקובץ פתוח אף תהליך אחר לא יכול לכתוב לו
אילו הכי חשובים ומן הסתם יש עוד אטריביוטים

7) תזמון תהליכים
תור- FIFO (first in first out) זה אומר שיש קדימות לפי מי שנכנס קודם 
אותו דבר בדיוק זה שתורים שמחכים לזמן מעבד
אף על פי שהמעבר עושה רץ דבר אחד בזמן נתון, בגלל שיש הרבה תהליך שמחכים למשהו ניתן להריץ הרבה תהליכים במקביל
תזמון התהליכים מאפשרת לנו לנצל את זמן המעבד באופן מיטבי שיראה כאילו 2 תהליכים קורים במקביל
יש תחום כזה בתכנות שנקרא תכנות מקבילי שזה אומר לעשות בדיוק את הדבר הזה multiprocessing/multiprograming
חשוב להבין שזה לא אומר שהדברים באמת קורים במקביל אלא שהמעבד מריץ את שניהם עם הפסקות ונותן לנו את ההרגשה שזה במקביל

8) החלפת הקשר
משל ספר וטלפון
כשהתוכנה במצב מחכה program counter זה נחמד אבל אנחנו צריכים את ההקשר, איזה משתנים שמורים איזה פונקציות קראו לאיזה פונקציות וכו'
הדבר הזה נקרא קונטקטס סוויצ', הדבר הזה לוקח למעבד כח מחשוב (כי הוא צריך להתעסק בניהול של זה), תוכנה טובה תהסה להימנע מכך כמה שיותר
קונטקס סוויצ כולל (שמירת המצב הנוכחי של התהליך והחלפה לתהלליך הבא שבתור)

9) שיטת תזמון תהליכים
להתעסק בפריפריה במקום בדבר עצמו (ביצוע הקוד) נקרא תקורה (overhead)
כשתהליך רץ יש כמה תהליכים במצב ready שמחכים בתור
אנחנו נדבר על היתרונות וחסרונות של תור
יתרונות: תור הוא "הוגן" fairness
חסרונות: 1. יש הרבה תהליכים שרצים במערכת ההפעלה, נגיד שיש תהליך במערכת ההפעלה שהוא אחראי על התזמון, אז מן הסתם התהליך הזה חשוב יותר מתהליך שרץ כרגע
אז לפעמים יש תהליכים שהעדיפות שלהם אמורה להיות יותר מתהליכים אחרים
2. מה עם תהליך נתקע ולא משחרר (כמו לולאה אין סופית), מה יקרה לשאר התהליכים? הם לעולם לא יכנסו לפעולה , הדבר הזה נקרא "הרעבה" Starvation

שיטת תזמון אחרת נקראת "תור עם עדיפויות", יהיו פרוססים שיקבלו עדיפות מסויימת Priority
יתרון יותר הגיוני מתזמון תהליכים רגיל
חיסרון, לא פותר את הבעיה של הרעבה

שיטה נוספת נקראת Round Robin
היא נותנת לכל פרוסס זמן קצוב, למשל חצי שניה, ברגע שתהליך סיים את הזמן שלו הוא מקבל הפרעה ועובר למצב Ready (כמובן בהנחה שהפרוסס הזה לא סיים את הריצה בזמן שהוא רץ
יתרון: הוגן, כל הפרוססים מקבלים זמן מעבד. יתרון נוסף הוא שאין הרעבה
חיסרון: מעמיס על המעבד בגלל הcontext switch, ולכן גורם לתקורה/ overhead

נכון שכל הדברים האלו קשורים למערכת הפעלה, אבל זה יפגוש אתכם הרבה גם בתור מתכנתים

10) יצירת תהליכים
המושג עץ הוא כמו בעבודות שורשים
יש שורש שהוא האב הקדמון, לקווים באמצע ההיררכיה קוראים ענפים, לקווים בסוף ההיררכיה קוראים עלים
לכל ישות אנחנו קוראים צומת (node) 
אותו דבר במערכת הפעלה
יש אב קדמון שנקרא kernel, לו יש ילדים:
מנהל זיכרון, מתזמן, אחראי החלפות הקשר (כל אלו הם קשורים לkernel)
בואו נאמר שהמתזמן מריץ את התהליך שלנו, הוא מריץ את הCLI והCLI מריץ את התהליך שלנו
באותה מידה המתזמן יכול להריץ GUI והGUI יכול להריץ כל תוכנה אחרת 
אנחנו נלמד בהמשך איך באמצעות קוד פייתון אנו יכולים ליצור פרוססים ילדים

11) בואו נראה איך אנחנו מקשרים את זה לקוד
יש הרבה סוגים של CLI
בווינדוס: command prompt או powershell
בלינוקס: bash / shell
בOSX אפל: terminal zsh

למשל אם כתבתי בCLI את הפקודה python, יצרנו תהליך חדש, אפשר לתת פקודה os.getpid() 
אנחנו יכולים לראות את הPID של האבא באמצעות getppid() קיצור ל get parent pid

12) יצירת תהליכים בפייתון
מהשיעור הזה זה יתחיל להיות פרקטי

13) מבוא לריצה במקביל

14) שיתוף מידע בין תהליכים
בדרך כלל אין שיתוף מידע בין תהליכים (יש להם גישה למשתנים מלפני אבל לא יותר מזה
כדי לשתף מידע יש כל מיני דרכים, למשל אחסונם בתוך אובייקט תור
שיתוף המידע הזה נקרא IPC, inter process comunication

15) דוגמא לתכנות מקבילי
מתי בעצם נשתמש בתכנות מקבילי
מתי לא? בדברים שקשורים לזמן מעבד, מעבד יכול לבצע רק פעולה אחת בו זמנית, לכן זה לא יעזור לו שהמשימה הזו תחולק ל2 תהליכים,, כי הוא יבצע את אותה פעולה, רק שזה יהיה יותר גרוע כי הוא יבזבז משאבים במעבר בין תהליכים
מתי כן? בIO, אם מחכים לאינפוט מסויים ובאותו זמן אנחנו רוצים לבצע משהו אחר, זה יכול להיות מקרה טוב לתכנות מקבילי

16) ת'רדים (חוטים)
ת'רדים יודעים לעשות מקביליות לעיתים יותר טוב מריבוי תהליכים
ברגע שנוצר פרוסס נותר גם ת'רד והוא מריץ את הפרוסס T1 מריץ את P1
איזה יתרון יש בת'רדים?
פרוסס דורש הרבה משאבים, הוא יכול גם ליצור פרוססים אחרים וצריך ניהול זיכרון
תכלס אנחנו לא באמת צריכים את כל זה, אנחנו בסך הכל צריכים ישות שיכולה לעזור בהרצה מקבילית, והיא לוקחת פחות מאמצים מצד המעבד
רק פרוסס יכול ליצור ת'רד, אבל ת'רד לא יכול ליצור כלום
ת'רדים לא מקבלים הקצאת זיכרון חדשה

| מאפיין           | תהליך (Process)                          | ת'רד (Thread)                              |
| ---------------- | ---------------------------------------- | ------------------------------------------ |
| **הגדרה**        | יחידת ביצוע עצמאית עם זיכרון נפרד        | יחידת ביצוע בתוך תהליך                     |
| **זיכרון**       | לכל תהליך מרחב זיכרון משלו               | משתפים את אותו מרחב זיכרון בתהליך האב      |
| **תקשורת**       | מסובכת – באמצעות מנגנונים כמו IPC        | פשוטה – שיתוף משתנים                       |
| **מהירות יצירה** | איטית יותר                               | מהירה יותר                                 |
| **קריסות**       | קריסה משפיעה רק על התהליך הנוכחי         | קריסה של ת'רד אחד עלולה להפיל את כל התהליך |
| **ביצועים**      | לרוב פחות יעילים                         | יעילים יותר לביצוע מקבילי                  |
| **שימוש עיקרי**  | הרצת תוכנות שונות (כמו דפדפן, עורך טקסט) | הרצת משימות במקביל באותה תוכנה             |
| **תלות**         | עצמאי                                    | תלוי בתהליך האב                            |

17) תרדים בקוד

18) קטע קריטי
Critical section
דוגמא קטע קוד:
a = 0
a = a+1
print(a) # 1
מה קורה בעצם? 
1. המעבד קורא את הערך 0 (ושומר עותק זמני ברגיסטרים)
2. המעבד מוסיף לערך 1
3. המעבד שומר את הערך 1 בכתובת של a
כך זה בחיים הרגילים
מה יקרה בת'רדים
ייתכן שת'רד 1 יבצע את 1 ו2, אך לא את 3, 
ואז ת'רד 2 יבצע גם את 1, 2, וכשהוא יקרא את a מהזיכרון הוא יקבל עדיין את 0, כי תר'ד 1 לא שמר אותו
משום שאין לנו שליטה מתי מערכת ההפעלה תעשה קונטקס סוויצ'
יכולה להיות חוסר אחידות בין הריצות, קוד לא קוסטינטנטי

יש לנו מושג לתאר את המלחמה על המעבד בין הת'רדים שנקרא race condition, מירוץ

מהו קטע קריטי? הקטע הקריטי בקוד, הוא הקטע שאם נריץ אותו במקביל עלולות להיווצר בעיות
למשל בדוגמא למעלה הקטע הקריטי הוא השורה השניה
ALU הוא החלק במעבד שאחראי על פעולות חישוביות
יש לנו עוד מושג שנקרא פעולה אטומית, שהיא בעצם חלקיק של פעולה, כמו קריאת ערך, שבזמן זה לא יכול להיות החלפת הקשר
אנחנו יכולים להפוך כמה שורות לפעולה אטומית, כמו את שלושת השורות שראינו כאן וכך לפתור את הבעיה הזו

19)קוד קטע קריטי

20) איך מתמודדים עם קטע קריטי
1. מנעול, הת'רד נועל את הקטע הקריטי, עד שהוא מסיים אותו, שום ת'רד לא יכול לגשת אליו, 
הת'רד שלא מחזיק במנעול יכול או לחכות לו ולישון בנתיים, או BUSY WAIT, נקרא גם SPIN LOCK הוא ישאל כל הזמן את המעבד אם המנעול הוסר
BUSY WAIT מבזבז זמן מעבד, אבל היתרון הוא שהוא מיד יקרה
ניתן לומר שהת'רדים מונעים אחד מהשני שימוש באופן הדדי (mutual exlusion) והקיצור של זה הוא MUTEX

2. שיטה נוספת SEMAPHORE מאוד דומה למנעול רק שאומר שכמה ת'רדים יכולים להיכנס במקביל, למשל רק 2 מתוך 10
3. 

21) דדלוק Deadlock
דדלוק מדבר על מצב שששמו מנעול על קטע והוא עושה בל מיני פעולות, ולכן אף אחד לא יכול להתשתמש במשאב היקר הזה
בואו ניקר כדוגמא צומת בכביש, המשאב היקר הוא אמצע הצומת, והרמזורים עושים לנו מנעולים
נגיד שנתקע רכב באמצע הצומת והרמזור לא מתחלף, הוא גורם לכל שאר הרכבים הרעבה
בעיה נוספת: אם לא ניהלנו נכון את הצומת, כל הרכבים עלולים להיכנס על אמצע הצומת, ולתקוע את כל הצומת המצב הזה הוא DEADLOCK


22)